// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: line.sql

package db

import (
	"context"
	"time"

	decimal "github.com/shopspring/decimal"
)

const createLine = `-- name: CreateLine :one
INSERT INTO lines (
  title,
  owner,
  account_id,
  month_id,
  category_id,
  year_id,
  amount,
  checked,
  description,
  due_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, owner, title, account_id, month_id, year_id, category_id, amount, checked, description, due_date
`

type CreateLineParams struct {
	Title       string          `json:"title"`
	Owner       string          `json:"owner"`
	AccountID   int64           `json:"account_id"`
	MonthID     int64           `json:"month_id"`
	CategoryID  int64           `json:"category_id"`
	YearID      int64           `json:"year_id"`
	Amount      decimal.Decimal `json:"amount"`
	Checked     bool            `json:"checked"`
	Description string          `json:"description"`
	DueDate     time.Time       `json:"due_date"`
}

func (q *Queries) CreateLine(ctx context.Context, arg CreateLineParams) (Line, error) {
	row := q.db.QueryRow(ctx, createLine,
		arg.Title,
		arg.Owner,
		arg.AccountID,
		arg.MonthID,
		arg.CategoryID,
		arg.YearID,
		arg.Amount,
		arg.Checked,
		arg.Description,
		arg.DueDate,
	)
	var i Line
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Title,
		&i.AccountID,
		&i.MonthID,
		&i.YearID,
		&i.CategoryID,
		&i.Amount,
		&i.Checked,
		&i.Description,
		&i.DueDate,
	)
	return i, err
}

const deleteLine = `-- name: DeleteLine :exec
DELETE FROM lines WHERE id = $1
`

func (q *Queries) DeleteLine(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteLine, id)
	return err
}

const getExpliciteLine = `-- name: GetExpliciteLine :one
SELECT lines.id, lines.owner, lines.title, accounts.title as account, months.title as month, categories.title as category, lines.amount, lines.checked, lines.description, lines.due_date FROM lines
JOIN accounts ON accounts.id = lines.account_id
JOIN months ON months.id = lines.month_id
JOIN categories ON categories.id = lines.category_id
WHERE lines.id = $1
`

type GetExpliciteLineRow struct {
	ID          int64           `json:"id"`
	Owner       string          `json:"owner"`
	Title       string          `json:"title"`
	Account     string          `json:"account"`
	Month       string          `json:"month"`
	Category    string          `json:"category"`
	Amount      decimal.Decimal `json:"amount"`
	Checked     bool            `json:"checked"`
	Description string          `json:"description"`
	DueDate     time.Time       `json:"due_date"`
}

func (q *Queries) GetExpliciteLine(ctx context.Context, id int64) (GetExpliciteLineRow, error) {
	row := q.db.QueryRow(ctx, getExpliciteLine, id)
	var i GetExpliciteLineRow
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Title,
		&i.Account,
		&i.Month,
		&i.Category,
		&i.Amount,
		&i.Checked,
		&i.Description,
		&i.DueDate,
	)
	return i, err
}

const getLine = `-- name: GetLine :one
SELECT id, owner, title, account_id, month_id, year_id, category_id, amount, checked, description, due_date FROM lines
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetLine(ctx context.Context, id int64) (Line, error) {
	row := q.db.QueryRow(ctx, getLine, id)
	var i Line
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Title,
		&i.AccountID,
		&i.MonthID,
		&i.YearID,
		&i.CategoryID,
		&i.Amount,
		&i.Checked,
		&i.Description,
		&i.DueDate,
	)
	return i, err
}

const getLineForUpdate = `-- name: GetLineForUpdate :one
SELECT id, owner, title, account_id, month_id, year_id, category_id, amount, checked, description, due_date FROM lines
WHERE id = $1 LIMIT 1 FOR NO KEY UPDATE
`

func (q *Queries) GetLineForUpdate(ctx context.Context, id int64) (Line, error) {
	row := q.db.QueryRow(ctx, getLineForUpdate, id)
	var i Line
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Title,
		&i.AccountID,
		&i.MonthID,
		&i.YearID,
		&i.CategoryID,
		&i.Amount,
		&i.Checked,
		&i.Description,
		&i.DueDate,
	)
	return i, err
}

const listExplicitLines = `-- name: ListExplicitLines :many
SELECT lines.id, lines.owner, lines.title, accounts.title as account, months.title as month, categories.title as category, lines.amount, lines.checked, lines.description, lines.due_date FROM lines
JOIN accounts ON accounts.id = lines.account_id
JOIN months ON months.id = lines.month_id
JOIN categories ON categories.id = lines.category_id
WHERE lines.owner = $1
ORDER BY lines.due_date DESC
LIMIT $2
OFFSET $3
`

type ListExplicitLinesParams struct {
	Owner  string `json:"owner"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListExplicitLinesRow struct {
	ID          int64           `json:"id"`
	Owner       string          `json:"owner"`
	Title       string          `json:"title"`
	Account     string          `json:"account"`
	Month       string          `json:"month"`
	Category    string          `json:"category"`
	Amount      decimal.Decimal `json:"amount"`
	Checked     bool            `json:"checked"`
	Description string          `json:"description"`
	DueDate     time.Time       `json:"due_date"`
}

func (q *Queries) ListExplicitLines(ctx context.Context, arg ListExplicitLinesParams) ([]ListExplicitLinesRow, error) {
	rows, err := q.db.Query(ctx, listExplicitLines, arg.Owner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExplicitLinesRow{}
	for rows.Next() {
		var i ListExplicitLinesRow
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Title,
			&i.Account,
			&i.Month,
			&i.Category,
			&i.Amount,
			&i.Checked,
			&i.Description,
			&i.DueDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLines = `-- name: ListLines :many
SELECT id, owner, title, account_id, month_id, year_id, category_id, amount, checked, description, due_date FROM lines
WHERE owner = $1
ORDER BY due_date DESC
LIMIT $2
OFFSET $3
`

type ListLinesParams struct {
	Owner  string `json:"owner"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListLines(ctx context.Context, arg ListLinesParams) ([]Line, error) {
	rows, err := q.db.Query(ctx, listLines, arg.Owner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Line{}
	for rows.Next() {
		var i Line
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Title,
			&i.AccountID,
			&i.MonthID,
			&i.YearID,
			&i.CategoryID,
			&i.Amount,
			&i.Checked,
			&i.Description,
			&i.DueDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLine = `-- name: UpdateLine :one
UPDATE lines
SET title = $2, account_id = $3, month_id = $4, category_id = $5, year_id = $6, amount = $7, checked = $8, description = $9, due_date = $10
WHERE id = $1
RETURNING id, owner, title, account_id, month_id, year_id, category_id, amount, checked, description, due_date
`

type UpdateLineParams struct {
	ID          int64           `json:"id"`
	Title       string          `json:"title"`
	AccountID   int64           `json:"account_id"`
	MonthID     int64           `json:"month_id"`
	CategoryID  int64           `json:"category_id"`
	YearID      int64           `json:"year_id"`
	Amount      decimal.Decimal `json:"amount"`
	Checked     bool            `json:"checked"`
	Description string          `json:"description"`
	DueDate     time.Time       `json:"due_date"`
}

func (q *Queries) UpdateLine(ctx context.Context, arg UpdateLineParams) (Line, error) {
	row := q.db.QueryRow(ctx, updateLine,
		arg.ID,
		arg.Title,
		arg.AccountID,
		arg.MonthID,
		arg.CategoryID,
		arg.YearID,
		arg.Amount,
		arg.Checked,
		arg.Description,
		arg.DueDate,
	)
	var i Line
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Title,
		&i.AccountID,
		&i.MonthID,
		&i.YearID,
		&i.CategoryID,
		&i.Amount,
		&i.Checked,
		&i.Description,
		&i.DueDate,
	)
	return i, err
}
